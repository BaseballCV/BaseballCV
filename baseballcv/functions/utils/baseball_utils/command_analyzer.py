import pandas as pd
import numpy as np
import os
import glob
from typing import List, Dict, Tuple, Optional

# Import the new helper function and other necessary utilities
from baseballcv.functions.utils.utils import get_statcast_data_for_game
from baseballcv.utilities import BaseballCVLogger, ProgressBar

class CommandAnalyzer:
    """
    Analyzes pitcher command by comparing catcher's glove target proxy
    from GloveTracker CSVs with actual pitch locations from Statcast data.

    Reads tracking data generated by the GloveTracker class and integrates
    external pitch outcome data (e.g., Statcast) fetched dynamically per game
    to calculate command metrics based on the methodology proposed in the
    "Measuring Pitching Command and Control" document.
    """

    def __init__(
        self,
        glove_tracking_dir: str, # Directory containing GloveTracker CSVs
        logger: Optional[BaseballCVLogger] = None,
        verbose: bool = True
    ):
        """
        Initialize the CommandAnalyzer.

        Args:
            glove_tracking_dir (str): Path to the directory containing GloveTracker CSV files.
                                      This directory should contain subdirectories or files
                                      named in the format 'tracked_{game_pk}_{play_id}_tracking.csv'.
            logger (BaseballCVLogger, optional): Logger instance. If None, creates a default logger.
            verbose (bool): Whether to print verbose logs.
        """
        self.glove_tracking_dir = glove_tracking_dir
        self.logger = logger if logger else BaseballCVLogger.get_logger(self.__class__.__name__)
        self.verbose = verbose
        # Cache for storing fetched Statcast data per game_pk
        self.game_statcast_cache: Dict[int, Optional[pd.DataFrame]] = {}

        if not os.path.isdir(glove_tracking_dir):
             raise FileNotFoundError(f"Glove tracking directory not found: {glove_tracking_dir}")

        self.logger.info(f"CommandAnalyzer initialized. Reading CSVs from: {glove_tracking_dir}")

    def _extract_ids_from_filename(self, filename: str) -> Tuple[Optional[int], Optional[str]]:
        """Extracts game_pk and Statcast play_id from GloveTracker CSV filename."""
        # Example filename: tracked_744865_cb7199c2-909e-4396-8621-9871f116fb20_tracking.csv
        basename = os.path.basename(filename)
        parts = basename.replace("tracked_", "").replace("_tracking.csv", "").split('_')

        if len(parts) == 2:
            game_pk_str, play_id = parts
            try:
                game_pk = int(game_pk_str)
                # Basic validation for play_id (UUID format)
                if len(play_id.split('-')) == 5:
                    return game_pk, play_id
            except ValueError:
                self.logger.warning(f"Could not parse game_pk as integer from filename: {basename}")
        else:
            self.logger.warning(f"Could not extract game_pk and play_id from filename: {basename}")

        return None, None

    def _find_intent_frame(self, df: pd.DataFrame, velocity_threshold: float = 5.0) -> Optional[int]:
        """
        Identifies the 'intent frame' based on glove stability (low velocity).

        Placeholder implementation - needs refinement based on pitch timing.

        Args:
            df (pd.DataFrame): DataFrame for a single pitch.
            velocity_threshold (float): Velocity (inches/frame) below which the glove is stable.

        Returns:
            Optional[int]: The identified intent frame index, or None.
        """
        # Filter out rows where glove position is missing or interpolated
        valid_glove_frames = df[
            df['glove_processed_x'].notna() &
            df['glove_processed_y'].notna() &
            (df['is_interpolated'] == False)
        ].copy()

        if len(valid_glove_frames) < 2:
            self.logger.debug("Not enough valid glove frames (<2) to calculate velocity.")
            return None

        valid_glove_frames = valid_glove_frames.sort_values(by='frame_idx').reset_index()

        # Calculate frame difference (dt)
        valid_glove_frames['dt'] = valid_glove_frames['frame_idx'].diff().fillna(1.0) # fill first dt with 1
        valid_glove_frames.loc[valid_glove_frames['dt'] <= 0, 'dt'] = 1.0 # Ensure dt is at least 1

        # Calculate displacement (dx, dy)
        valid_glove_frames['dx'] = valid_glove_frames['glove_processed_x'].diff().fillna(0)
        valid_glove_frames['dy'] = valid_glove_frames['glove_processed_y'].diff().fillna(0)

        # Calculate velocity in inches per frame
        valid_glove_frames['velocity'] = np.sqrt(valid_glove_frames['dx']**2 + valid_glove_frames['dy']**2) / valid_glove_frames['dt']

        # --- Intent Frame Logic ---
        # Simplistic: Find the last frame index where velocity was below the threshold.
        # TODO: Improve this logic, e.g., find the last stable frame *before* estimated pitch arrival.
        stable_frames = valid_glove_frames[valid_glove_frames['velocity'] < velocity_threshold]

        if not stable_frames.empty:
            intent_frame = int(stable_frames['frame_idx'].iloc[-1])
            self.logger.debug(f"Identified potential intent frame: {intent_frame} (Velocity < {velocity_threshold})")
            return intent_frame
        else:
             # Fallback: If no stable frame found, maybe use the frame with highest confidence?
             # Or the frame closest to the start if stability wasn't achieved?
             # For now, returning None if no clearly stable frame identified by this simple logic.
             self.logger.debug("Could not find a stable intent frame based on velocity threshold.")
             # Consider returning the index of the minimum velocity frame if necessary:
             # min_vel_idx = valid_glove_frames['velocity'].idxmin()
             # return int(valid_glove_frames.loc[min_vel_idx, 'frame_idx'])
             return None


    def calculate_command_metrics(
        self,
        csv_path: str,
        game_statcast_df: Optional[pd.DataFrame]
        ) -> Optional[Dict]:
        """
        Calculates command deviation for a single pitch from its tracking CSV,
        using the provided Statcast data for that game.

        Args:
            csv_path (str): Path to the GloveTracker CSV file for one pitch.
            game_statcast_df (pd.DataFrame, optional): Statcast data for the specific game
                                                      containing this pitch.

        Returns:
            Optional[Dict]: Dictionary containing command metrics for the pitch, or None.
        """
        if not os.path.exists(csv_path):
            self.logger.error(f"CSV file not found: {csv_path}")
            return None

        game_pk, play_id = self._extract_ids_from_filename(csv_path)
        if not play_id or game_pk is None:
            return None # Failed to get IDs

        try:
            track_df = pd.read_csv(csv_path)
        except Exception as e:
            self.logger.error(f"Failed to read tracking CSV {csv_path}: {e}")
            return None

        # --- Find Intent Frame ---
        intent_frame_idx = self._find_intent_frame(track_df, velocity_threshold=5.0) # Threshold needs tuning

        if intent_frame_idx is None:
            self.logger.warning(f"Could not determine intent frame for play_id {play_id} (Game {game_pk}). Skipping.")
            return None

        # Get glove target coordinates at the intent frame
        intent_frame_data_rows = track_df[track_df['frame_idx'] == intent_frame_idx]
        if intent_frame_data_rows.empty:
             self.logger.warning(f"Intent frame {intent_frame_idx} not found in data for play_id {play_id}. Skipping.")
             return None
        intent_frame_data = intent_frame_data_rows.iloc[0]

        # Use 'glove_processed_x/y' as the target proxy from tracker
        glove_target_x = intent_frame_data['glove_processed_x']
        glove_target_y = intent_frame_data['glove_processed_y']

        if pd.isna(glove_target_x) or pd.isna(glove_target_y):
             self.logger.warning(f"Glove target coords missing for intent frame {intent_frame_idx} in play_id {play_id}. Skipping.")
             return None

        # --- Get Actual Pitch Location (Statcast) ---
        if game_statcast_df is None or game_statcast_df.empty:
             self.logger.warning(f"Statcast data not available for game {game_pk} (needed for play {play_id}). Cannot calc deviation.")
             return None

        statcast_pitch = game_statcast_df[game_statcast_df['play_id'] == play_id]

        if statcast_pitch.empty:
            self.logger.warning(f"No Statcast data found for play_id {play_id} within game {game_pk} data. Skipping.")
            return None

        # Ensure required columns exist
        if not all(col in statcast_pitch.columns for col in ['plate_x', 'plate_z']):
            self.logger.warning(f"Statcast location data (plate_x, plate_z) missing for play_id {play_id}. Skipping.")
            return None

        # Assuming Statcast 'plate_x', 'plate_z' are in feet relative to center of plate.
        # GloveTracker 'glove_real_x', 'glove_real_y' are in inches relative to center of plate.
        try:
            actual_pitch_x_ft = statcast_pitch['plate_x'].iloc[0]
            actual_pitch_z_ft = statcast_pitch['plate_z'].iloc[0]

            if pd.isna(actual_pitch_x_ft) or pd.isna(actual_pitch_z_ft):
                 raise ValueError("Statcast location is NaN")

            actual_pitch_x_inches = actual_pitch_x_ft * 12.0
            actual_pitch_z_inches = actual_pitch_z_ft * 12.0 # Using plate_z for vertical
        except (TypeError, ValueError, IndexError) as e:
             self.logger.warning(f"Invalid Statcast location data for play_id {play_id}: {e}. Skipping.")
             return None


        # --- Calculate Deviation ---
        # NOTE: Ensure coordinate systems align! GloveTracker 'glove_processed_y' Y+ is UP from plate center.
        # Statcast 'plate_z' Z+ is UP from ground.
        # This calculation assumes glove_processed_y corresponds to the vertical dimension relative to plate center.
        dev_x = actual_pitch_x_inches - glove_target_x
        dev_y = actual_pitch_z_inches - glove_target_y # Compare Statcast Z with Glove Y

        deviation_inches = np.sqrt(dev_x**2 + dev_y**2)

        results = {
            "game_pk": game_pk,
            "play_id": play_id,
            "intent_frame": intent_frame_idx,
            "glove_target_x": glove_target_x,
            "glove_target_y": glove_target_y,
            "actual_pitch_x": actual_pitch_x_inches,
            "actual_pitch_z": actual_pitch_z_inches,
            "deviation_inches": deviation_inches,
            "deviation_vector_x": dev_x,
            "deviation_vector_y": dev_y
        }
        return results

    def analyze_folder(self, output_csv: str = "command_analysis_results.csv") -> pd.DataFrame:
        """
        Analyzes all GloveTracker CSV files in the specified directory, fetching
        Statcast data per game as needed.

        Args:
            output_csv (str): Path relative to glove_tracking_dir to save the results CSV file.

        Returns:
            pd.DataFrame: DataFrame containing command metrics for all processed pitches.
        """
        csv_files = glob.glob(os.path.join(self.glove_tracking_dir, "tracked_*_tracking.csv")) + \
                    glob.glob(os.path.join(self.glove_tracking_dir, "*", "tracked_*_tracking.csv")) # Include subdirs
        csv_files = list(set(csv_files)) # Remove duplicates if found in both root and subdir

        if not csv_files:
            self.logger.error(f"No GloveTracker CSV files found in {self.glove_tracking_dir} or its subdirectories.")
            return pd.DataFrame()

        all_results = []
        self.logger.info(f"Found {len(csv_files)} tracking files to analyze.")

        # Use ProgressBar for iteration
        for csv_file in ProgressBar(iterable=csv_files, desc="Analyzing Pitch Command"):
            game_pk, play_id = self._extract_ids_from_filename(csv_file)
            if game_pk is None or play_id is None:
                self.logger.warning(f"Skipping file due to invalid name format: {csv_file}")
                continue

            # Check cache for Statcast data for this game
            if game_pk not in self.game_statcast_cache:
                self.logger.info(f"Statcast data for game {game_pk} not cached. Fetching...")
                # Fetch data for the game if not in cache
                statcast_df = get_statcast_data_for_game(game_pk, self.logger)
                self.game_statcast_cache[game_pk] = statcast_df # Store even if None to avoid refetching

            # Get the cached data (could be None if fetching failed)
            current_game_statcast_df = self.game_statcast_cache.get(game_pk)

            # Calculate metrics for the pitch using the fetched/cached data
            pitch_metrics = self.calculate_command_metrics(csv_file, current_game_statcast_df)
            if pitch_metrics:
                 all_results.append(pitch_metrics)

        if not all_results:
             self.logger.warning("No pitches could be analyzed.")
             return pd.DataFrame()

        results_df = pd.DataFrame(all_results)

        # --- Merge with full Statcast data for context ---
        # Consolidate all fetched statcast data
        all_statcast_dfs = [df for df in self.game_statcast_cache.values() if df is not None]
        if all_statcast_dfs:
            full_statcast_df = pd.concat(all_statcast_dfs, ignore_index=True)
            # Ensure play_id is the correct type for merging if needed
            if 'play_id' in full_statcast_df.columns:
                 full_statcast_df['play_id'] = full_statcast_df['play_id'].astype(str)
                 results_df['play_id'] = results_df['play_id'].astype(str)


                # Select only relevant Statcast columns to merge (avoid duplication except play_id)
                cols_to_merge = ['play_id', 'pitcher', 'batter', 'pitch_type', 'p_throws', 'stand',
                                'balls', 'strikes', 'outs_when_up', 'release_speed',
                                'release_pos_x', 'release_pos_z', 'pfx_x', 'pfx_z'] # Add other desired cols
                valid_cols_to_merge = [col for col in cols_to_merge if col in full_statcast_df.columns]

                if 'play_id' in valid_cols_to_merge:
                    results_df = pd.merge(
                        results_df,
                        full_statcast_df[valid_cols_to_merge].drop_duplicates(subset=['play_id']), # Avoid duplicate rows if play_id appears in multiple fetched games (shouldn't happen ideally)
                        on='play_id',
                        how='left',
                        suffixes=('', '_statcast') # Add suffix to avoid column name conflicts if any overlap besides key
                    )
                    # Clean up potentially duplicated columns after merge if needed
                    results_df = results_df[[col for col in results_df.columns if not col.endswith('_statcast')]]

        # --- Save results ---
        # Save relative to the *input* directory
        output_path = os.path.join(self.glove_tracking_dir, output_csv)
        try:
            results_df.to_csv(output_path, index=False)
            self.logger.info(f"Command analysis results saved to {output_path}")
        except Exception as e:
            self.logger.error(f"Failed to save results CSV to {output_path}: {e}")

        return results_df

    def calculate_aggregate_metrics(self, results_df: pd.DataFrame, group_by: List[str] = ['pitcher']) -> pd.DataFrame:
        """
        Calculates aggregate command metrics grouped by specified columns.

        Args:
            results_df (pd.DataFrame): DataFrame from analyze_folder().
            group_by (List[str]): List of columns to group by (e.g., ['pitcher'], ['pitcher', 'pitch_type']).

        Returns:
            pd.DataFrame: DataFrame with aggregate metrics (AvgDev, StdDevDev, Cmd%).
        """
        if 'deviation_inches' not in results_df.columns:
            self.logger.error("Input DataFrame must contain 'deviation_inches' column.")
            return pd.DataFrame()

        # Ensure grouping columns exist after potential merge issues
        valid_group_by = [col for col in group_by if col in results_df.columns]
        if len(valid_group_by) != len(group_by):
             missing_groups = [col for col in group_by if col not in valid_group_by]
             self.logger.error(f"Grouping columns not found in DataFrame: {missing_groups}. Grouping by available columns: {valid_group_by}")
             if not valid_group_by:
                 return pd.DataFrame() # Cannot group if no valid columns remain
             group_by = valid_group_by # Use only the valid columns

        # Filter out rows where deviation couldn't be calculated
        results_df_filtered = results_df.dropna(subset=['deviation_inches'])
        if results_df_filtered.empty:
            self.logger.warning("No valid deviation data found for aggregation.")
            return pd.DataFrame()

        # Define command threshold (e.g., 6 inches) - Make it configurable?
        CMD_THRESHOLD_INCHES = 6.0
        results_df_filtered['is_commanded'] = results_df_filtered['deviation_inches'] <= CMD_THRESHOLD_INCHES

        # Check for NaN grouping keys before grouping
        if results_df_filtered[group_by].isnull().any().any():
            nan_cols = results_df_filtered[group_by].isnull().any()
            self.logger.warning(f"NaN values found in grouping columns: {nan_cols[nan_cols].index.tolist()}. Rows with NaN group keys will be excluded from aggregation.")
            results_df_filtered = results_df_filtered.dropna(subset=group_by)


        if results_df_filtered.empty:
             self.logger.warning("DataFrame empty after dropping NaN group keys.")
             return pd.DataFrame()

        agg_metrics = results_df_filtered.groupby(group_by, dropna=True).agg( # Ensure dropna is explicit
            AvgDev_inches=('deviation_inches', 'mean'),
            StdDev_inches=('deviation_inches', 'std'),
            CmdPct=('is_commanded', lambda x: x.mean() * 100 if not x.empty else 0), # Handle empty groups
            Pitches=('play_id', 'count')
        ).reset_index()

        # Fill NaN StdDevDev with 0 if only one pitch in group
        if 'StdDev_inches' in agg_metrics.columns:
            agg_metrics['StdDev_inches'] = agg_metrics['StdDev_inches'].fillna(0)

        agg_metrics.rename(columns={'CmdPct': f'Cmd%_<{CMD_THRESHOLD_INCHES}in'}, inplace=True)

        self.logger.info(f"Calculated aggregate metrics grouped by: {group_by}")
        return agg_metrics